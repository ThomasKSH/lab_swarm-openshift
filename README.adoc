:sectanchors:
:toc: macro
:toclevels: 2
:toc-title: Table of Content
:numbered:

= Hands On Lab with Wildfly Swarm, Microservices & OpenShift

toc::[]

# Prerequisites

you will need to install the following on your machine:

- [x] http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[JDK 1.8]
- [x] https://maven.apache.org/download.cgi[Maven 3.3.6 or higher]
- [x] https://www.virtualbox.org/wiki/Downloads[Virtualbox 5.0 or higher]
- [x] https://github.com/minishift/minishift[Minishift 1.0.0.Beta3]
- [x] https://github.com/openshift/origin/releases/tag/v1.4.1[OpenShift Client 1.4.1]
- [x] https://forge.jboss.org/download[JBoss Forge]
- [x] http://developers.redhat.com/products/devstudio/download/?referrer=jbd[JBoss Developer Studio 10 (optional)]

# Installation of OpenShift

In order to use OpenShift platform on your laptob, we will use the Minishift Go clientApplication which has been created from the Minikube project of Kubernetes. It extends the features proposed by the Kubernetes client to package/deploy
OpenShift within a VM machine. Different hypervisors are supported as Virtualbox, xhyve & VMWare. You can find more information about Minishift like also how to install it from the project:
https://github.com/minishift/minishift

We will configure the VM on the machine using Virtualbox as Hypervisor, the version of OpenShift used is `1.4.1`. It is the default verison used by minishift 1.0.0.Beta3
To create the Virtual Machine, open a Terminal and execute this command.

[source]
----
minishift start --memory=4000 --vm-driver=virtualbox

Starting local OpenShift instance using 'virtualbox' hypervisor...
Provisioning OpenShift via '/Users/chmoulli/.minishift/cache/oc/v1.4.0-rc1/oc [cluster up --use-existing-config --host-config-dir /var/lib/minishift/openshift.local.config --host-data-dir /var/lib/minishift/hostdata]'
-- Checking OpenShift client ... OK
-- Checking Docker client ... OK
-- Checking Docker version ... OK
-- Checking for existing OpenShift container ...
   Deleted existing OpenShift container
-- Checking for openshift/origin:v1.4.0-rc1 image ... OK
-- Checking Docker daemon configuration ... OK
-- Checking for available ports ... OK
-- Checking type of volume mount ...
   Using Docker shared volumes for OpenShift volumes
-- Creating host directories ... OK
-- Finding server IP ...
   Using 192.168.64.25 as the server IP
-- Starting OpenShift container ...
   Starting OpenShift using container 'origin'
   Waiting for API server to start listening
   OpenShift server started
-- Removing temporary directory ... OK
-- Server Information ...
   OpenShift server started.
   The server is accessible via web console at:
       https://192.168.99.101:8443

   To login as administrator:
       oc login -u system:admin
----

Next, we will provide more rights for the admin `default` user in order to let it to access the different projects/namespaces to manage the resources.
This step is only required if you use the new Minishift client (>= 1.0.0.Beta3).

You can retrieve the provate address of the VM using the `minishift ip` command.

[source]
----
oc login https://$(minishift ip):8443 -u system:admin
oc adm policy add-cluster-role-to-user cluster-admin admin
oc login -u admin -p admin
oc project default
----

Remark : Optionally you can install OpenShift templates in order to have more examples to play on the platform as WildFly Server, MongoDb, MySQL Server, ...

[source]
----
export currentDir=$(pwd)
cd $TEMP_DIR
git clone https://github.com/openshift/openshift-ansible.git
cd openshift-ansible/roles/openshift_examples/files/examples/latest/
for f in image-streams/image-streams-centos7.json; do cat $f | oc create -n openshift -f -; done
for f in db-templates/*.json; do cat $f | oc create -n openshift -f -; done
for f in quickstart-templates/*.json; do cat $f | oc create -n openshift -f -; done
cd $currentDir
----

# Goals

The goal of this lab is to create a Microservices application that we will deploy within a virtualized environment managed by OpenShift.
The project will contain 3 modules; a web static Front end, a backend service exposed by WildFly Swarm & a MySQL database.

Each module will be packaged and deployed as a Docker image on OpenShift. The OpenShift Source to Image Tool (= https://docs.openshift.com/enterprise/3.2/creating_images/s2i.html[S2I]) will be used for that purpose.
It will use the Java S2I Docker image responsible to build the final Docker image of your project using the source code of the maven module uploaded to the openshift platform.
This step will be performed using the https://maven.fabric8.io/[Fabric8 Maven Plugin]. This Maven plugin is a Java Kubernetes/OpenShift client able to communicate with the Openshift platform using the REST endpoints
in order to issue the commands allowing to build aproject, deploy it and finally launch a docker process as a pod.

The project will be created using a Java IDE "IntelliJ, JBoss Developer Studio" tool while JBoss Forge will help us to design the Java application in order to:
- Create the REST Service
- Modelize the JPA Entity & the model
- Scaffold the AngularJS application

# Create project

We will follow the following steps in order to create the maven projects with the modules. Some prerequisites are required like JBoss Forge.

## All in one

[source]
----
./scritpts/create_vm.sh

 ./scripts/setup.sh
----

## Decomposed steps

- Open a terminal and next create the snowcamp project
[source]
----
mkdir snowcamp
----

- Create the parent maven project where we will design the Front and the backend modules

[source]
----
mvn archetype:generate -DarchetypeGroupId=org.codehaus.mojo.archetypes -DarchetypeArtifactId=pom-root -DarchetypeVersion=RELEASE -DinteractiveMode=false -DgroupId=org.cdstore -DartifactId=project -Dversion=1.0.0-SNAPSHOT
mv project snowcamp && cd snowcamp
----

- Next create the `cdservice` maven module usign the following forge command where the stack to be used is Java EE
[source]
----
project-new --named cdservice --stack JAVA_EE_7
----

- Setup the JPA entity and the Hibernate persistence file. Define the persistence unit and datasource
[source]
----
# Define PostgreSQL DB
jpa-setup --jpa-provider hibernate --db-type MYSQL --data-source-name java:jboss/datasources/CatalogDS --persistence-unit-name cdservice-persistence-unit
[source]
----

- Create a Catalog entity class with the folloing fields
[source]
----
jpa-new-entity --named Catalog
jpa-new-field --named artist --target-entity org.cdservice.model.Catalog
jpa-new-field --named title --target-entity org.cdservice.model.Catalog
jpa-new-field --named description --length 2000 --target-entity org.cdservice.model.Catalog
jpa-new-field --named price --type java.lang.Float --target-entity org.cdservice.model.Catalog
jpa-new-field --named publicationDate --type java.util.Date --temporalType DATE --target-entity org.cdservice.model.Catalog
----

- Add the MySQL Database Driver & the

- Generate the REST endpoints
[source]
----
rest-generate-endpoints-from-entities --targets org.cdservice.model.*
----

- Use the Forge scaffold command to generate the AngularJS content able to map the screens with the CRUD services exposed by the REST service
[source]
----
scaffold-setup --provider AngularJS
scaffold-generate --provider AngularJS --generate-rest-resources --targets org.cdservice.model.*
----

- Setup the maven module as a WildFly Swarm project and scan the project to detect the fractions to be included (Datasource, ...)
[source]
----
wildfly-swarm-setup
wildfly-swarm-detect-fractions --depend --build
----

- Add MySQL Driver
[source]
----
project-add-dependencies mysql:mysql-connector-java:5.1.40
----

- As the service will be called from a resources which is not running from the same HTTP Server and domain, a REST filter should be created to add the CORS Headers
[source]
----
cd cdservice
rest-new-cross-origin-resource-sharing-filter
----

- Now, we will like for Swarm setup the project as a Fabric8 project
[source]
----
fabric8-setup
cd ..
----

- Change the version of the Fabric8 Maven plugin from 3.2.9 to 3.1.92
- Add the generator wildfly-swarm that we will use

[source]
----
<plugin>
   <groupId>io.fabric8</groupId>
   <artifactId>fabric8-maven-plugin</artifactId>
   <version>3.1.92</version>
   <executions>
     <execution>
       <id>fmp</id>
       <goals>
         <goal>resource</goal>
         <goal>helm</goal>
         <goal>build</goal>
       </goals>
     </execution>
   </executions>
   <configuration>
     <generator>
       <includes>
         <include>wildfly-swarm</include>
       </includes>
     </generator>
   </configuration>
 </plugin>
----

- Create the store front project
[source]
----
# ----------------  CD Store Web Front End [:8081/rest] ---------------
# Now we want to create front end swarm service to access CD Catalog Service
project-new --named cdstorefrontend --stack JAVA_EE_7 --type wildfly-swarm --http-port 8081
wildfly-swarm-add-fraction --fractions undertow
----

- Copy resources and scripts
[source]
----
mv ../cdservice/src/main/webapp/ src/main/


# Keep empty src/main/webapp/WEB-INF
mkdir ../cdservice/src/main/webapp
mkdir ../cdservice/src/main/webapp/WEB-INF
----

- Change the version of the Fabric8 Maven plugin from 3.2.9 to 3.1.92
- Add the generator wildfly-swarm that we will use

[source]
----
<plugin>
        <groupId>io.fabric8</groupId>
        <artifactId>fabric8-maven-plugin</artifactId>
        <version>3.1.92</version>
        <executions>
          <execution>
            <id>fmp</id>
            <goals>
              <goal>resource</goal>
              <goal>helm</goal>
              <goal>build</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <generator>
            <includes>
              <include>wildfly-swarm</include>
            </includes>
          </generator>
        </configuration>
      </plugin>
----

- Deploy on Openshift using the `fabric8:deploy` maven goal

  mvn fabric8:deploy

# Externalize Front Service

- Create service.json file under webapp folder & define the following key/value

  { "cd-service": "http://localhost:8080/rest/catalogs/" }
  { "cd-service": "http://cdservice-snowcamp.192.168.99.119.xip.io/rest/catalogs/" }

- Add a config.js file within the directory scripts containing a $http.get request to access the content
  of the json file & fetch the key `cd-service`. This key will contain the hostname or service name to be accessed

[source]
----
angular.module('cdservice').factory('config', function ($http, $q) {
  var deferred = $q.defer();
  var apiUrl = null;
  $http.get("service.json")
    .success(function (data) {
      console.log("Resource : " + data['cd-service'] + ':CatalogId');
      deferred.resolve(data['cd-service']);
      apiUrl = data['cd-service'];
    })
    .error(function () {
      deferred.reject('could not find service.json ....');
    });

  return {
    promise: deferred.promise,
    getApiUrl: function () {
      return apiUrl;
    }
  };
});
----

- Modify the `scripts/services/CatalogFactory.js` to use the function `config` instead of the hard coded value

[source]
----
  return $resource(config.getApiUrl() + ':CatalogId', { CatalogId: '@id' }, {
----

- Edit the app.html page to add the new script externalizing the URL

    <script src="scripts/services/config.js"></script>

- Add a svc.yml under src/main/fabric8 where the target port is 8081 in order to create a service
[source]
----
apiVersion: v1
kind: Service
metadata:
  name: ${project.artifactId}
spec:
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8081
  type: ClusterIP
----

- Create a route.yml file under src/main/fabric8 to tell to Openshift to create a route
[source]
----
apiVersion: v1
kind: Route
metadata:
  name: ${project.artifactId}
spec:
  port:
    targetPort: 8080
  to:
    kind: Service
    name: ${project.artifactId}
----

- Deploy the cdfront project
[source]
----
mvn fabric8:deploy
----

- Check that you can access the HTML page of the Front

  http://cdfront-snowcamp.192.168.99.119.xip.io/

# Database

- Install the OpenShift MySQL Template

  oc new-app --template=mysql-ephemeral \
      -p MYSQL_USER=mysql \
      -p MYSQL_PASSWORD=mysql \
      -p MYSQL_DATABASE=catalogdb

- Next, check if the Database is up and alive

[source]
----
export pod=$(oc get pod | grep mysql | awk '{print $1}')
oc rsh $pod
mysql -u $MYSQL_USER -p$MYSQL_PASSWORD -h $HOSTNAME $MYSQL_DATABASE

mysql> connect catalogdb;
Connection id:    1628
Current database: catalogdb

mysql> SELECT t.* FROM catalogdb.Catalog t;
+----+--------+---------+
| id | name   | version |
+----+--------+---------+
|  1 | abba   |       0 |
|  2 | acdc   |       0 |
|  3 | boston |       0 |
|  4 | u2     |       0 |
+----+--------+---------+
----

- Insert some records (if the table has been created !)

[source]
----
INSERT INTO Catalog (id, artist, description, price, publicationDate, title) VALUES (1,"ACDC","Australian hard rock band", 15.0, '1980-07-25', "Back in Black");
INSERT INTO Catalog (id, artist, description, price, publicationDate, title) VALUES (2,"Abba","Swedish pop music group", 12.0, '1976-10-11', "Arrival");
INSERT INTO Catalog (id, artist, description, price, publicationDate, title) VALUES (3,"Coldplay","British rock band ", 17.0, '2008-07-12', "Viva la Vida");
INSERT INTO Catalog (id, artist, description, price, publicationDate, title) VALUES (4,"U2","Irish rock band ", 18.0, '1987-03-09', "The Joshua Tree");
INSERT INTO Catalog (id, artist, description, price, publicationDate, title) VALUES (5,"Metallica","Heavy metal band", 15.0, '1991-08-12', "Black");
----


# Test project locally

- Open 2 terminal in order to start the front & backend
- cd `cdservice`

  npm install
  export PORT=8081
  export URL=http://localhost:8080/rest/catalogs

  OpenShift URL : "http://cdstorefrontend-snowcamp.192.168.99.101.xip.io/rest/catalogs/"

- cd `cdstorefront`

  mvn wildfly-swarm:run

- Open project within your browser `http://localhost:8081/index.html`

- Forward the traffic from the service to the host using `port-forwarding` command

[source]
----
export pod=$(oc get pod | grep mysql | awk '{print $1}')
oc port-forward $pod 3306:3306
----








